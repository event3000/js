(function(){
'use strict';
// =======================================================================
// Задание 1
// (+) 1.1. создать 2 объекта sity1 и sity2 со следующими свойствами: 
// name, population, mayor 
// двумя разными способами (первый объект одним способом, второй другим)


// (+)1.2. sity1 добавить метод, который позволяет забирать какую-то часть населения sity2 (и соответственно добавлять к своему)

// 1.3. Написать функцию (вне этих объектов), которая показывает мэра города (в зависимости от объекта, переданного ей в качестве аргумента)

// 1.4. Создать объект president c методом changeCountryMayor(), благодаря которому он сможет менять мэра города (в зависимости от объекта, переданного в качестве аргумента)

console.log("Задание 4-1:",);
let sity1 = {
	name: "S town",
	population: 5000,
	mayor: "Smith",
    nail: function(n) {
			 sity1.population = sity1.population + n;
			 sity2.population = sity2.population - n;
		},
};

let sity2 = new Object();
sity2.name = "J town";
sity2.population = 1000;
sity2.mayor = "Jones";


// Вызов функции, в аргументе число людей (плюс или минус)
sity1.nail(600);
console.log("SITY1:",sity1,"SITY2:",sity2);



// Показ мэра города
function showMayor(x){
	if (x === sity1) {
		return sity1.mayor;
	} else if (x === sity2) {
			return sity2.mayor; 			
 	} else {
 		return "xz";
 	}
}
console.log("Показ мэра города:",showMayor(sity2));

// Создать объект president c методом changeCountryMayor()
// let = president {
// 	changeCountryMayor: function(n) {

// 		},
// }










// =======================================================================
// Задание 2

// Написать функцию, которая на вход принимает строку и подстроку и ищет ВСЕ вхождения подстроки в строку




// =======================================================================
// Задание 3 (по рядам, нумерация от окна)
// 1 ряд: написать функцию getDataFromUser(), которая:
// 1)получает информацию от пользователя,
// 2)используя, функцию validateData(data, flag) - ее создает второй ряд, проверяет данные на валидность. 
// Пример использования 
// validateData(a, 'num') 
// validateData(operator, 'operator')
// validateData(b, 'num')
// validateData(data, flag) возвращает либо true, либо false
// В случае, если данные не валидны, пытается получить их до тех пор, пока не получит пригодные данные, 

// 3)после чего возврящает их в виде массива [+a, operator, +b]
// Данная функция сначала получает первое число, потом оператор, потом второе число.
// Оператор нельзя начать получать, пока не получено первое валидное число, второе число нельзя начать получать, пока пользователь не введет подходящий оператор 
// Операторы могут быть + - * /

// 2 ряд: написать функцию validateData(data, flag), которая работает следующим образом:
// 1)если flag - 'num', data проверяется на число,
// если flag - 'operator', data провереятся на соответствие одному из операторов ('+', '-', '*' или '/')
// 2)a и b - могут быть только числами
// 3)если operator === /, второе число не может быть 0 
// 4)возвращает true, в случае, если условия проверки выполняется и false, если нет

// 3 ряд: написать функцию runCalculator():
// 1)уточняет у пользователя, действительно ли он хочет запустить программу:
// 2) в случае положительного ответа:
// 2.1)получат данные из функции getDataFromUser(), вида [+a, operator, +b], например [1, "+", 5]
// 2.2)разбивает массив на отдельные переменные 
// 2.3)вызывает функцию operations(a, operator, b), передавая в качестве аргументов, переменные из п.2)
// 2.4)результат работы operations выводит пользователю (для вывода использовать alert)
// 3) в случае отрицательного прощается с пользователем



// function operations(a, operator, b) {
// if (operator === '+') { 
// return a + b;
// } else if (operator === '-') { 
// return a - b; 
// } else if (operator === '*') { 
// return a * b; 
// } else return a / b; 
// }











}() );